<!DOCTYPE html><html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Documentation Projet Robots - Tekbot Challenge 2024</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header class="page-de-garde">
        <h1>Documentation Test_1 IT</h1>
        <h2>Tekbot Robotics Challenge 2025</h2>
        <p><strong>Langage utilis√© :</strong> Python</p>
        <p><strong>D√©velopp√© par :</strong> strategy-lab-unstim</p>
        <p><strong>Date :</strong> 12 Juin 2025</p>
    </header><nav class="table-matiere">
    <h2>üìò Table des mati√®res</h2>
    <ul>
        <li><a href="#intro">1. Introduction</a></li>
        <li><a href="#objectif">2. Objectif du projet</a></li>
        <li><a href="#outils">3. Pr√©requis et outils n√©cessaires</a></li>
        <li><a href="#structure">4. Structure du projet</a></li>
        <li><a href="#classrobot">5. D√©tail du fichier ClassRobot.py</a></li>
        <li><a href="#robot">6. D√©tail du fichier Robot.py</a></li>
        <li><a href="#gestion">7. D√©tail du fichier Gestion.py</a></li>
        <li><a href="#main">8. D√©tail du fichier main.py</a></li>
        <li><a href="#robot">9. Fichiers de types de robots</a>
            <ul>
                <li><a href="#menager">9.1 D√©tail du fichier Menager.py</a></li>
                <li><a href="#industriel">9.2 D√©tail du fichier Indistruel.py</a></li>
                <li><a href="#medical">9.3 D√©tail du fichier Medical.py</a></li>
                <li><a href="#explorateur">9.4 D√©tail du fichier Explorateur.py</a></li>
                <li><a href="#compagnon">9.5 D√©tail du fichier Compagnon.py</a></li>
            </ul>
        </li>
        <li><a href="#uml">10. Diagramme UML</a></li>
        <li><a href="#conclusion">11. Conclusion</a></li>
    </ul>
</nav>

<section id="intro">
    <h2>1. Introduction</h2>
    <p>Dans un contexte mondial o√π la robotique devient un pilier fondamental de l‚Äôinnovation technologique, les comp√©tences en programmation orient√©e objet (POO) et en conception de syst√®mes modulaires sont devenues essentielles. Le Tekbot Robotics Challenge 2024, organis√© au sein d‚Äôun cadre acad√©mique dynamique, offre aux √©tudiants une opportunit√© concr√®te de mobiliser ces comp√©tences dans un projet coh√©rent, pratique et professionnalisant.</p>
        <p>Ce projet consiste √† concevoir une application Python qui permet de simuler la cr√©ation et la gestion de diff√©rents types de robots, chacun ayant des caract√©ristiques propres, tout en partageant une base commune. L‚Äôapproche choisie repose sur une architecture modulaire, orient√©e objet, facilitant l‚Äôextensibilit√©, la r√©utilisabilit√© et la maintenabilit√© du code. Chaque type de robot est d√©fini dans un fichier sp√©cifique, h√©ritant d‚Äôune classe m√®re abstraite, et mettant en ≈ìuvre ses propres attributs et comportements.</p>
        <p>La pr√©sente documentation vise √† fournir une vue d‚Äôensemble compl√®te et structur√©e du projet : depuis les objectifs p√©dagogiques jusqu‚Äô√† l‚Äôimpl√©mentation technique d√©taill√©e de chaque composant. Elle s‚Äôadresse aussi bien aux √©tudiants d√©butants en programmation qu‚Äôaux d√©veloppeurs exp√©riment√©s d√©sireux d‚Äôexaminer une architecture propre, segment√©e et respectant les bonnes pratiques de d√©veloppement logiciel. Les explications sont accompagn√©es de codes comment√©s pour favoriser l‚Äôapprentissage et la compr√©hension progressive.</p>
</section>

<section id="objectif">
    <h2>2. Objectif du projet</h2>
    <p>L'objectif est de construire une application Python capable de g√©rer dynamiquement des objets repr√©sentant des robots sp√©cialis√©s. Chaque robot poss√®de des attributs g√©n√©raux (nom, fabricant, etc.) et sp√©cifiques selon son type (m√©dical, industriel, etc.). Le programme doit :</p>
    <ul>
        <li>Permettre √† l'utilisateur de cr√©er diff√©rents types de robots via un menu interactif.</li>
        <li>Assurer la validation des donn√©es entr√©es par l'utilisateur.</li>
        <li>Stocker les robots cr√©√©s en m√©moire et les sauvegarder dans un fichier texte.</li>
        <li>Impl√©menter le principe d‚Äôh√©ritage, d‚Äôabstraction, d‚Äôencapsulation et de polymorphisme.</li>
    </ul>
</section>

<section id="outils">
    <h2>3. Pr√©requis et outils n√©cessaires</h2>
    <ul>
        <li><strong>Langage :</strong> Python 3.8 ou sup√©rieur</li>
        <li><strong>Biblioth√®ques standards :</strong> abc, uuid</li>
        <li><strong>√âditeur conseill√© :</strong> VS Code, PyCharm ou Thonny</li>
        <li><strong>OS compatible :</strong> Windows, Linux, macOS</li>
        <li><strong>Connaissances requises :</strong> notions de POO, structures conditionnelles, boucles, saisies utilisateur</li>
    </ul>
</section>

<!-- Les autres sections restent inchang√©es, elles sont d√©j√† pr√©sentes dans la version pr√©c√©dente -->

<section id="structure">
    <h2>4. Structure du projet</h2>
    <p>Le projet est organis√© autour de fichiers sp√©cialis√©s :</p>
    <ul>
        <li><code>main.py</code> ‚Äì Point d‚Äôentr√©e de l‚Äôapplication</li>
        <li><code>ClassRobot.py</code> ‚Äì Classe de base abstraite</li>
        <li><code>Robot.py</code> ‚Äì D√©monstration simplifi√©e</li>
        <li><code>Gestion.py</code> ‚Äì Fonctions de menu, sauvegarde, saisie</li>
        <li><code>Menager.py</code>, <code>Indistruel.py</code>, etc. ‚Äì D√©finissent chaque type de robot</li>
    </ul>
</section>

<section id="classrobot">
    <h2>5. Fichier : ClassRobot.py</h2>
    <p>Ce fichier d√©finit la classe abstraite <code>Robot</code> qui sert de base √† toutes les autres. Il introduit des attributs g√©n√©raux comme le nom, mod√®le, fabricant, ann√©e de fabrication, batterie, capacit√©, vitesse, poids et statut. Il utilise <code>uuid</code> pour g√©n√©rer un identifiant unique et impose des m√©thodes abstraites √† impl√©menter dans les sous-classes.</p>
    <p><strong>Particularit√© :</strong> Ce fichier est central, car tous les robots h√©ritent de cette structure.</p>
</section>

<section id="robot">
    <h2>6. Fichier : Robot.py</h2>
    <p>Fichier simplifi√© pour l‚Äôinitiation √† la POO. Il contient la classe abstraite <code>Robot</code> avec les classes concr√®tes <code>FlyingRobot</code> et <code>WheeledRobot</code>, illustrant le polymorphisme. Il inclut aussi la classe <code>ClientGestion</code> pour cr√©er plusieurs robots √† la vol√©e.</p>
    <p><strong>Diff√©rence :</strong> Ce fichier est plus p√©dagogique et simplifi√© par rapport √† <code>ClassRobot.py</code>.</p>
</section>

<section id="gestion">
    <h2>7. Fichier : Gestion.py</h2>
    <p>Ce fichier regroupe les fonctions utiles pour l‚Äôinteraction utilisateur, la validation des entr√©es et la sauvegarde.</p>

    <h3>Fonction : demander_attributs()</h3>
    <p>Elle permet de demander √† l‚Äôutilisateur les attributs g√©n√©raux et sp√©cifiques d‚Äôun robot avec des validations int√©gr√©es.</p>
    <pre><code>def demander_attributs(generaux, specifiques):
    reponses = []
    for attr in generaux:
    if attr == "id_robot":
        continue
    # Validation pour certaines valeurs sp√©cifiques
    ...
    for attr in specifiques:
        if attr in ["interaction_voix", "detergent", ...]:
            val = input(f"{attr} (oui/non): ").lower() == "oui"
        else:
            val = input(f"{attr} : ")
        reponses.append(val)
    return reponses</code></pre>

        <h3>Fonction : sauvegarder_robots()</h3>
        <p>Enregistre les informations de tous les robots cr√©√©s dans un fichier texte.</p>
        <pre><code>def sauvegarder_robots(robots):
    with open("robots_crees.txt", "w", encoding="utf-8") as f:
        for robot in robots:
            f.write(f"=== {robot.get_type()} ===\n")
            for cle, val in robot.get_attributs_generaux().items():
                f.write(f"{cle} : {val}\n")
            for cle, val in robot.get_attributs_specifiques().items():
                f.write(f"{cle} : {val}\n")
            f.write("\n")</code></pre>

        <h3>Fonction : afficher_menu()</h3>
        <p>Affiche les diff√©rents types de robots disponibles √† la cr√©ation :</p>
        <pre><code>def afficher_menu():
    print("\n=== Types de robots disponibles ===")
    print("1. Robot M√©nager - Pour les t√¢ches domestiques")
    print("2. Robot Industriel - Pour les usines")
    ...
    print("6. Quitter le programme")</code></pre>
</section>

<section id="main">
    <h2>8. Fichier : main.py</h2>
    <p>Ce fichier est le centre du programme. Il orchestre le menu, appelle les fonctions de gestion, et cr√©e les objets robots.</p>

    <h3>Initialisation</h3>
    <p>Liste les attributs g√©n√©raux des robots et un dictionnaire des classes avec leurs attributs sp√©cifiques :</p>
    <pre><code>generaux = ["nom", "fabricant", "modele", "annee_fabrication",
        "batterie", "capacite_charge", "vitesse_max", "poids", "statut"]

robot_classes = { "1": ("RobotMenager", RobotMenager, ["type_tache", ...]), "2": ("RobotIndustriel", RobotIndustriel, ["type_usine", ...]), ... }</code></pre>

<h3>Boucle principale</h3>
    <p>Affiche le menu, r√©cup√®re le choix utilisateur, valide les donn√©es et cr√©e l'objet correspondant :</p>
    <pre><code>while True:
afficher_menu()
choix = input("Choisissez un type de robot : ").strip()
if choix == "6":
    sauvegarder_robots(robots_crees)
    break
if choix in robot_classes:
    nom, classe, specifiques = robot_classes[choix]
    attributs = demander_attributs(generaux, specifiques)
    robot = classe(*attributs[:9], **dict(zip(specifiques, attributs[9:])))
    robots_crees.append(robot)
    robot.move()</code></pre>

    <p><strong>Conclusion :</strong> C‚Äôest le c≈ìur fonctionnel du projet. C‚Äôest ici que tout converge : saisie, traitement, instanciation, d√©monstration, sauvegarde.</p>
    </section>

    <section id="robot">
        <h2>9. Robot.py ‚Äì Exemple simplifi√© de POO</h2>
        <p>Le fichier <code>Robot.py</code> est une version d‚Äôintroduction aux principes de la programmation orient√©e objet. Il ne fait pas directement partie du c≈ìur du projet principal, mais sert de base de d√©monstration avant d‚Äôaborder les classes avanc√©es du fichier <code>ClassRobot.py</code>.</p>

        <h3>Contenu du fichier</h3>
        <p>Il contient :</p>
        <ul>
            <li>Une classe abstraite <code>Robot</code> avec les attributs <code>name</code> et <code>model</code></li>
            <li>Deux classes filles : <code>FlyingRobot</code> et <code>WheeledRobot</code></li>
            <li>Une classe <code>ClientGestion</code> pour g√©rer la cr√©ation et l‚Äôaffichage des robots</li>
        </ul>

        <pre><code>from abc import ABC, abstractmethod

class Robot(ABC):
    def __init__(self, name, model):
        self._name = name
        self._model = model

    def get_name(self):
        return self._name

    def set_name(self, name):
        self._name = name

    def get_model(self):
        return self._model

    def set_model(self, model):
        self._model = model

    @abstractmethod
    def move(self):
        pass

    def __str__(self):
        return f"Robot {self._name}, mod√®le {self._model}"

class FlyingRobot(Robot):
    def move(self):
        return f"{self._name} vole dans les airs avec agilit√©."

class WheeledRobot(Robot):
    def move(self):
        return f"{self._name} roule rapidement sur le sol."

class ClientGestion:
    def __init__(self):
        self.robot_list = []

    def creation_robot(self):
        print("....... Cr√©ation du Robot .......")
        try:
            response = int(input('Entrer 1 pour FlyingBot ou 2 pour WheeledRobot : '))
            if response in [1, 2]:
                nom = input("Entrer le nom : ")
                model = input("Entrer le mod√®le : ")
                robot = FlyingRobot(nom, model) if response == 1 else WheeledRobot(nom, model)
                self.robot_list.append(robot)
            else:
                print("------ Entr√©e invalide -----")
        except ValueError:
            print("------ Entr√©e invalide -----")

    def count_robot(self):
        try:
            number_robot = int(input('Entrez le nombre de robots √† cr√©er : '))
            return number_robot
        except ValueError:
            print("------ Entr√©e invalide -----")
            return 0

client_gestion = ClientGestion()
number_of_robots = client_gestion.count_robot()
for _ in range(number_of_robots):
    client_gestion.creation_robot()

if client_gestion.robot_list:
    print("\nListe des robots cr√©√©s :")
    for i, robot in enumerate(client_gestion.robot_list, 1):
        print(f'Robot N¬∞ {i}')
        print(robot)
        print(robot.move())
else:
    print("\nAucun robot valide n'a √©t√© cr√©√©.")</code></pre>

        <h3>Objectif p√©dagogique</h3>
        <p>Ce fichier est utile pour :</p>
        <ul>
            <li>Comprendre l‚Äôusage d‚Äôune classe abstraite et l‚Äôobligation d‚Äôimpl√©menter <code>move()</code></li>
            <li>Expliquer le principe du polymorphisme (m√™me m√©thode <code>move()</code>, comportements diff√©rents)</li>
            <li>Initier √† la gestion dynamique d‚Äôobjets via la classe <code>ClientGestion</code></li>
        </ul>
        <p>Bien que simplifi√©, il pr√©pare √† la logique compl√®te du projet principal bas√© sur <code>ClassRobot.py</code>.</p>
    </section>


    <section id="menager">
        <h3>9.1 Menager.py</h3>
        <p>Ce fichier contient la d√©finition de la classe <code>RobotMenager</code>, qui h√©rite de la classe <code>Robot</code> dans <code>ClassRobot.py</code>. Cette classe est destin√©e √† simuler des robots domestiques : aspirateurs intelligents, laveurs de sol, robots de repassage, etc.</p>
        <pre><code>class RobotMenager(Robot):
    def __init__(self, *args, type_tache, reservoir, detergent, autonomie, niveau_bruit):
        super().__init__(*args)
        self.type_tache = type_tache
        self.reservoir = reservoir
        self.detergent = detergent
        self.autonomie = autonomie
        self.niveau_bruit = niveau_bruit

    def move(self):
        print(f"{self.get_nom()} commence √† nettoyer la maison.")

    def get_type(self):
        return "RobotM√©nager"

    def get_attributs_specifiques(self):
        return {
            "type_tache": self.type_tache,
            "reservoir": self.reservoir,
            "detergent": self.detergent,
            "autonomie": self.autonomie,
            "niveau_bruit": self.niveau_bruit
        }</code></pre>
        <p><strong>Explications :</strong></p>
        <ul>
            <li><code>type_tache</code> : d√©termine la sp√©cialisation du robot (ex : nettoyage, repassage...)</li>
            <li><code>reservoir</code> : capacit√© du r√©servoir d‚Äôeau ou de d√©chets</li>
            <li><code>detergent</code> : bool√©en indiquant si le robot peut utiliser des produits nettoyants</li>
            <li><code>autonomie</code> : dur√©e de fonctionnement en heures</li>
            <li><code>niveau_bruit</code> : bruit √©mis en d√©cibels (dB)</li>
        </ul>
        <p>Cette classe montre comment enrichir un mod√®le de base en ajoutant des attributs sp√©cifiques √† un contexte d‚Äôusage concret, ici l‚Äôentretien domestique.</p>
    </section>

    <section id="industriel">
        <h3>9.2 Fichier : Indistruel.py</h3>
        <p>Le fichier <code>Indistruel.py</code> contient la classe <code>RobotIndustriel</code>, con√ßue pour ex√©cuter des t√¢ches sp√©cifiques dans des environnements industriels. Ces robots sont souvent utilis√©s sur des cha√Ænes de production, pour du soudage, de l‚Äôassemblage ou de la manipulation d‚Äôobjets lourds. Cette classe h√©rite de <code>Robot</code> et ajoute des attributs propres √† l‚Äôusage industriel.</p>
        <pre><code>class RobotIndustriel(Robot):
    def __init__(self, *args, type_usine, outil_utilise, resistance_chaleur,
                 capacite_production, precision):
        super().__init__(*args)
        self.type_usine = type_usine
        self.outil_utilise = outil_utilise
        self.resistance_chaleur = resistance_chaleur
        self.capacite_production = capacite_production
        self.precision = precision

    def move(self):
        print(f"{self.get_nom()} se d√©place sur la cha√Æne de production.")

    def get_type(self):
        return "RobotIndustriel"

    def get_attributs_specifiques(self):
        return {
            "type_usine": self.type_usine,
            "outil_utilise": self.outil_utilise,
            "resistance_chaleur": self.resistance_chaleur,
            "capacite_production": self.capacite_production,
            "precision": self.precision
        }</code></pre>
        <p>Chaque attribut correspond √† une exigence du domaine industriel. Par exemple, <code>precision</code> d√©finit la tol√©rance en millim√®tres, tandis que <code>capacite_production</code> indique le nombre d‚Äôunit√©s trait√©es par heure.</p>
    </section>

    <section id="medical">
        <h3>9.3 Fichier : Medical.py</h3>
        <p>Ce fichier d√©finit la classe <code>RobotMedical</code>, con√ßue pour ex√©cuter des t√¢ches en environnement hospitalier. Il impl√©mente des attributs sp√©cifiques √† la pr√©cision et √† la s√©curit√© des interventions chirurgicales.</p>
        <pre><code>class RobotMedical(Robot):
    def __init__(self, *args, type_operation, sterilisable, telecommande,
                 compatibilite_scan, precision_chirurgicale):
        super().__init__(*args)
        self.type_operation = type_operation
        self.sterilisable = sterilisable
        self.telecommande = telecommande
        self.compatibilite_scan = compatibilite_scan
        self.precision_chirurgicale = precision_chirurgicale

    def move(self):
        print(f"{self.get_nom()} se positionne pour une intervention chirurgicale.")

    def get_type(self):
        return "RobotMedical"

    def get_attributs_specifiques(self):
        return {
            "type_operation": self.type_operation,
            "sterilisable": self.sterilisable,
            "telecommande": self.telecommande,
            "compatibilite_scan": self.compatibilite_scan,
            "precision_chirurgicale": self.precision_chirurgicale
        }</code></pre>
    </section>

    <section id="explorateur">
        <h3>9.4 Fichier : Explorateur.py</h3>
        <p>La classe <code>RobotExplorateur</code> est destin√©e √† mod√©liser un robot capable d‚Äôop√©rer dans des environnements extr√™mes (oc√©an, espace, d√©serts, etc.).</p>
        <pre><code>class RobotExplorateur(Robot):
    def __init__(self, *args, type_exploration, profondeur_max, communication,
                 resistance, capacite_analyse):
        super().__init__(*args)
        self.type_exploration = type_exploration
        self.profondeur_max = profondeur_max
        self.communication = communication
        self.resistance = resistance
        self.capacite_analyse = capacite_analyse

    def move(self):
        print(f"{self.get_nom()} avance dans une zone inhospitali√®re.")

    def get_type(self):
        return "RobotExplorateur"

    def get_attributs_specifiques(self):
        return {
            "type_exploration": self.type_exploration,
            "profondeur_max": self.profondeur_max,
            "communication": self.communication,
            "resistance": self.resistance,
            "capacite_analyse": self.capacite_analyse
        }</code></pre>
    </section>

    <section id="compagnon">
        <h3>9.5 Fichier : Compagnon.py</h3>
        <p>Le fichier <code>Compagnon.py</code> d√©finit un robot d‚Äôassistance ou de compagnie. Ce type de robot est utilis√© dans l‚Äôaccompagnement des personnes √¢g√©es, l‚Äô√©ducation, ou m√™me comme assistants personnels intelligents. Cette classe est ax√©e sur l‚Äôinteraction humaine et int√®gre des fonctions li√©es √† la communication et √† l‚Äôadaptation comportementale.</p>
        <pre><code>class RobotCompagnon(Robot):
    def __init__(self, *args, intelligence_sociale, interaction_voix,
                 apprentissage, reconnaissance_visage, divertissement):
        super().__init__(*args)
        self.intelligence_sociale = intelligence_sociale
        self.interaction_voix = interaction_voix
        self.apprentissage = apprentissage
        self.reconnaissance_visage = reconnaissance_visage
        self.divertissement = divertissement

    def move(self):
        print(f"{self.get_nom()} suit son utilisateur pour l'assister.")

    def get_type(self):
        return "RobotCompagnon"

    def get_attributs_specifiques(self):
        return {
            "intelligence_sociale": self.intelligence_sociale,
            "interaction_voix": self.interaction_voix,
            "apprentissage": self.apprentissage,
            "reconnaissance_visage": self.reconnaissance_visage,
            "divertissement": self.divertissement
        }</code></pre>
        <p>Cette classe est id√©ale pour illustrer la programmation orient√©e vers les interactions intelligentes. Elle pose aussi les bases pour des extensions futures int√©grant des modules de traitement du langage naturel ou de reconnaissance faciale avanc√©e.</p>
    </section>
</section>

<section id="uml">
    <h2>10. Diagramme UML</h2>
    <p>Le diagramme UML ci-dessous montre la hi√©rarchie des classes, avec <code>Robot</code> comme base et les diff√©rents types de robots comme sous-classes :</p>
    <img src="images/uml-diagram.png" alt="Diagramme UML" style="width: 100%; max-width: 800px;">
</section>

<section id="conclusion">
    <h2>11. Conclusion</h2>
    <p>√Ä travers le Tekbot Robotics Challenge 2024, les √©tudiants ont eu l‚Äôopportunit√© de s‚Äôimmerger dans une exp√©rience de d√©veloppement logiciel compl√®te. Le projet abord√© permet d‚Äôappliquer concr√®tement les principes de la programmation orient√©e objet tout en r√©pondant √† un cahier des charges r√©aliste, centr√© sur la cr√©ation, la personnalisation et la gestion de plusieurs types de robots.</p>
        <p>La qualit√© du code repose sur une architecture modulaire bien pens√©e : chaque fichier a une responsabilit√© claire (single responsibility), les interactions sont ma√Ætris√©es et les d√©pendances limit√©es. Les validations de donn√©es, la s√©paration entre logique m√©tier et interface utilisateur (console), ainsi que l‚Äôusage de m√©thodes abstraites favorisent un haut niveau de maintenabilit√©.</p>
        <p>Cette documentation a √©t√© pens√©e comme un guide pratique, technique et p√©dagogique. Elle peut servir de support d‚Äôapprentissage √† ceux qui d√©couvrent la POO, mais aussi de point de d√©part pour des √©volutions plus ambitieuses : ajout d‚Äôinterface graphique (Tkinter, PyQt), base de donn√©es SQLite, d√©ploiement d‚ÄôAPI REST avec Flask ou FastAPI, ou encore int√©gration avec des capteurs et microcontr√¥leurs dans un contexte r√©el de robotique embarqu√©e.</p>
        <p>En somme, ce projet est bien plus qu‚Äôun exercice scolaire. Il constitue une base solide pour tout d√©veloppeur ou ing√©nieur souhaitant explorer les fondements d‚Äôune architecture orient√©e objet propre, testable et √©volutive dans le domaine de la robotique logicielle et des syst√®mes intelligents.</p>
    </section>

<footer>
    <p>&copy; 2025 - strategy-lab-unstim</p>
</footer>


</body>
</html>

